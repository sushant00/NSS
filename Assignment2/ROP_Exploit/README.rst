SIMPLE ROP EXPLOIT
*******************

.. contents:: **Contents of this document**
   :depth: 2


Description
===========
We are given a binary (named 'victim-nonexec-stack') which has SSP turned off and also the stack is non executable. We want to perform a rop exploit. We would force the victim to call the execve system call and eventually halt program to shut the system down.

Get Started
===========

Step 0
------
We would first turn the ASLR off (which is enabled by default on modern systems). We add the line **kernel.randomize_va_space=0** to end of file **/etc/sysctl.conf** and apply the changes by running the following command

.. code:: shell

	$ sysctl -p

Next **install the rop gadget tool** from https://github.com/JonathanSalwan/ROPgadget


Step 1
------
We would now generate the input to pass to the vicitm

.. code:: shell

	$ sh gen_input.sh

Step 2
-------
Finally, exploit the victim program

.. code:: shell

	$ ./victim < input
	


Implementation
==============
Running gdb victim-nonexec-stack and then disas main shows the assembly code for the victim program. After analyzing it is clear that the buffer size is **64 bytes**. We also obtain the address of buffer analyzing the program using gdb.

Stack Structure
----------------
The script **gen_input.sh** generates the input such that the buffer fills and creates the stack structure as shown:

string NULL
null terminator for '-p'
\-----------------------------------------------------------------------
string '-p' (NULL terminated array)
\-----------------------------------------------------------------------
string NULL
null terminator for '/sbin/halt'
\-----------------------------------------------------------------------
string '/sbin/halt'
\-----------------------------------------------------------------------
null address (0x00 00 00 00 00 00 00 00)
\-----------------------------------------------------------------------
address of string '-p' (stored above)
\-----------------------------------------------------------------------
address of string '/sbin/halt' (stored above)
\-----------------------------------------------------------------------
address of execve() (in libc)
\-----------------------------------------------------------------------
null address (0x00 00 00 00 00 00 00 00)
\-----------------------------------------------------------------------
address to instruction: pop %rdx; ret;
\-----------------------------------------------------------------------
address of array of address of 'sbin/halt' and '-p' and null
i.e. the address of the array of NULL terminated arguments for execve
\-----------------------------------------------------------------------
address to instruction: pop %rsi; ret;
\-----------------------------------------------------------------------
address of string '/sbin/halt' (filename)
\-----------------------------------------------------------------------
address to instruction: pop %rdi; ret;
\-----------------------------------------------------------------------
RBP register
\-----< both RBP and buff overwritten by nops
Buffer (64 bytes)
\------------------------------------------------------------------------


Address of libc
----------------
Address where the libc is loaded into victim program can be found by running following command:

.. code:: shell

	$ ldd ./victim-nonexec-stack


Offset for gadgets
------------------
Run the following command on shell, and look for the offsets of required gadgets.
We would use:

- pop rdi; ret;
- pop rsi; ret;
- pop rdx; ret;

.. code:: shell

	$ ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --ropchain



Offset for execve
------------------
Run the following command on shell, to find the offset of execve.

.. code:: shell

	$ nm -D /lib/x86_64-linux-gnu/libc.so.6 | grep execve

gen_input.sh
------------
This script generates the required input for rop exploit.

- It first puts 72 nops(this can be any byte) bytes, so that the next address it puts is the place where the victim program return
- Then puts the address of **pop rdi;ret;** instruction present in libc. 
- puts Address of string **'/sbin/halt'**. On returning victim pops these 8 bytes into rdi, and hence we place the address of filename as the **first argument to execve**.
- Then puts the address of **pop rsi;ret;** instruction in libc. So that on returning from **pop rdi; ret**; these instructions are executed.
- puts the address of array of argumens. This is filled as **second argument to execve** into **rsi**.
- puts the address of **pop rdx; ret;** instruction in libc.
- puts **8 null bytes**. These are passed as **third argument to execve** into **rdx**. This is null as we don't want to pass any pointer to envp array (third argument of execve)
- puts the address of **execve** function. So that finally execve is called on returning.
- puts the address of string '/sbin/halt', address of str '-p' and Null pointer. This forms the array of arguments to execve (passed into rsi).
- puts the string **/sbin///////halt** onto stack. We have added extra '/' just to make our life easy and make the size of string 16 bytes (multiple of 8). Address of next string '-p' would thus be at multiple of 8. Note that '/' are ignored in filename, so this won't create any problem.
- puts the null terminator for previous string, 8 bytes (again to make the addresses multiple of 8)
- puts the string '-p'
- puts the null terminator for previous string, 8 bytes (again to make the addresses multiple of 8)


Reference
=========
https://github.com/finallyjustice/security/tree/master/rop/demo1
https://failingsilently.wordpress.com/2017/12/14/rop-chain-shell/

Author: Sushant Kumar Singh